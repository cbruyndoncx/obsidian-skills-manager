import { Vault } from 'obsidian';
import { scanSkills } from './scanner';
import { CATEGORY_ORDER, CATEGORY_DISPLAY } from './types';

const EXPORT_TARGETS: Record<string, string> = {
  cursor: '.cursor/rules/skills.md',
  copilot: '.github/copilot-instructions.md',
  windsurf: '.windsurf/rules/skills.md',
  cline: '.clinerules/skills.md',
};

export const EXPORT_TARGET_LABELS: Record<string, string> = {
  cursor: 'Cursor',
  copilot: 'GitHub Copilot',
  windsurf: 'Windsurf',
  cline: 'Cline',
};

/**
 * Extract the body content from a SKILL.md file (everything after frontmatter).
 */
function extractBody(content: string): string {
  const match = content.match(/^---\r?\n[\s\S]*?\r?\n---\r?\n?([\s\S]*)$/);
  return match ? match[1].trim() : content.trim();
}

/**
 * Export enabled skills to config files for other AI tools.
 */
export async function exportSkills(
  vault: Vault,
  skillsDir: string,
  targets: string[]
): Promise<{ exported: string[]; errors: string[] }> {
  const exported: string[] = [];
  const errors: string[] = [];
  const adapter = vault.adapter;

  // Scan enabled skills
  const skills = await scanSkills(vault, skillsDir);
  const enabledSkills: { name: string; body: string }[] = [];

  for (const [folderName, meta] of skills) {
    if (meta.disableModelInvocation) continue;

    const skillFile = `${skillsDir}/${folderName}/SKILL.md`;
    try {
      const content = await adapter.read(skillFile);
      const body = extractBody(content);
      if (body) {
        enabledSkills.push({ name: meta.name, body });
      }
    } catch {
      errors.push(`Could not read ${skillFile}`);
    }
  }

  if (enabledSkills.length === 0) {
    errors.push('No enabled skills to export');
    return { exported, errors };
  }

  // Build combined content
  const sections = enabledSkills.map(
    (s) => `## ${s.name}\n${s.body}`
  );
  const combined = `# Skills (auto-generated by Skills Manager)\n\n${sections.join('\n\n---\n\n')}\n`;

  // Write to each target
  for (const target of targets) {
    const path = EXPORT_TARGETS[target];
    if (!path) {
      errors.push(`Unknown export target: ${target}`);
      continue;
    }

    try {
      // Ensure parent directories exist (handles nested paths like .cursor/rules/)
      const parts = path.split('/');
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join('/');
        if (dir && !(await adapter.exists(dir))) {
          await adapter.mkdir(dir);
        }
      }

      await adapter.write(path, combined);
      exported.push(EXPORT_TARGET_LABELS[target] || target);
    } catch (e) {
      errors.push(
        `Failed to write ${path}: ${e instanceof Error ? e.message : String(e)}`
      );
    }
  }

  return { exported, errors };
}

/**
 * Generate SKILLS.md index at vault root listing all enabled skills grouped by category.
 */
export async function generateSkillsIndex(
  vault: Vault,
  skillsDir: string,
  defaultCategory = 'uncategorized'
): Promise<void> {
  const skills = await scanSkills(vault, skillsDir, defaultCategory);

  // Group by category
  const grouped = new Map<string, { name: string; description: string }[]>();
  for (const [, meta] of skills) {
    if (meta.disableModelInvocation) continue;
    const cat = meta.category;
    if (!grouped.has(cat)) grouped.set(cat, []);
    grouped.get(cat)!.push({ name: meta.name, description: meta.description });
  }

  // Build content in category order
  const lines: string[] = ['# Available Skills', ''];

  // Known categories first, in order
  for (const cat of CATEGORY_ORDER) {
    const entries = grouped.get(cat);
    if (!entries || entries.length === 0) continue;
    const displayName = CATEGORY_DISPLAY[cat] || cat.charAt(0).toUpperCase() + cat.slice(1);
    lines.push(`## ${displayName}`);
    for (const s of entries.sort((a, b) => a.name.localeCompare(b.name))) {
      lines.push(`- ${s.name}: ${s.description}`);
    }
    lines.push('');
    grouped.delete(cat);
  }

  // Any remaining categories not in the predefined order
  for (const [cat, entries] of grouped) {
    if (entries.length === 0) continue;
    const displayName = cat.charAt(0).toUpperCase() + cat.slice(1);
    lines.push(`## ${displayName}`);
    for (const s of entries.sort((a, b) => a.name.localeCompare(b.name))) {
      lines.push(`- ${s.name}: ${s.description}`);
    }
    lines.push('');
  }

  const total = Array.from(skills.values()).filter(m => !m.disableModelInvocation).length;
  lines.push(`Total: ${total} enabled skills`);
  lines.push('');

  await vault.adapter.write('SKILLS.md', lines.join('\n'));
}

import { Vault } from 'obsidian';
import { scanSkills } from './scanner';

const EXPORT_TARGETS: Record<string, string> = {
  cursor: '.cursor/rules/skills.md',
  copilot: '.github/copilot-instructions.md',
  windsurf: '.windsurf/rules/skills.md',
  cline: '.clinerules/skills.md',
};

export const EXPORT_TARGET_LABELS: Record<string, string> = {
  cursor: 'Cursor',
  copilot: 'GitHub Copilot',
  windsurf: 'Windsurf',
  cline: 'Cline',
};

/**
 * Extract the body content from a SKILL.md file (everything after frontmatter).
 */
function extractBody(content: string): string {
  const match = content.match(/^---\r?\n[\s\S]*?\r?\n---\r?\n?([\s\S]*)$/);
  return match ? match[1].trim() : content.trim();
}

/**
 * Export enabled skills to config files for other AI tools.
 */
export async function exportSkills(
  vault: Vault,
  skillsDir: string,
  targets: string[]
): Promise<{ exported: string[]; errors: string[] }> {
  const exported: string[] = [];
  const errors: string[] = [];
  const adapter = vault.adapter;

  // Scan enabled skills
  const skills = await scanSkills(vault, skillsDir);
  const enabledSkills: { name: string; body: string }[] = [];

  for (const [folderName, meta] of skills) {
    if (meta.disableModelInvocation) continue;

    const skillFile = `${skillsDir}/${folderName}/SKILL.md`;
    try {
      const content = await adapter.read(skillFile);
      const body = extractBody(content);
      if (body) {
        enabledSkills.push({ name: meta.name, body });
      }
    } catch {
      errors.push(`Could not read ${skillFile}`);
    }
  }

  if (enabledSkills.length === 0) {
    errors.push('No enabled skills to export');
    return { exported, errors };
  }

  // Build combined content
  const sections = enabledSkills.map(
    (s) => `## ${s.name}\n${s.body}`
  );
  const combined = `# Skills (auto-generated by Skills Manager)\n\n${sections.join('\n\n---\n\n')}\n`;

  // Write to each target
  for (const target of targets) {
    const path = EXPORT_TARGETS[target];
    if (!path) {
      errors.push(`Unknown export target: ${target}`);
      continue;
    }

    try {
      // Ensure parent directories exist (handles nested paths like .cursor/rules/)
      const parts = path.split('/');
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join('/');
        if (dir && !(await adapter.exists(dir))) {
          await adapter.mkdir(dir);
        }
      }

      await adapter.write(path, combined);
      exported.push(EXPORT_TARGET_LABELS[target] || target);
    } catch (e) {
      errors.push(
        `Failed to write ${path}: ${e instanceof Error ? e.message : String(e)}`
      );
    }
  }

  return { exported, errors };
}

/**
 * Generate SKILLS.md index at vault root listing all enabled skills grouped by category,
 * plus a slash commands section for user-invocable skills.
 */
export async function generateSkillsIndex(
  vault: Vault,
  skillsDir: string,
  defaultCategory = 'uncategorized'
): Promise<void> {
  const skills = await scanSkills(vault, skillsDir, defaultCategory);

  // Collect enabled skills grouped by category, and user-invocable commands
  const grouped = new Map<string, { name: string; description: string }[]>();
  const commands: { name: string; path: string; description: string }[] = [];

  for (const [folderName, meta] of skills) {
    if (meta.disableModelInvocation) continue;
    const cat = meta.category;
    if (!grouped.has(cat)) grouped.set(cat, []);
    grouped.get(cat)!.push({ name: meta.name, description: meta.description });

    if (meta.userInvocable) {
      commands.push({
        name: meta.name,
        path: `${skillsDir}/${folderName}/SKILL.md`,
        description: meta.description,
      });
    }
  }

  // Build content — categories sorted alphabetically
  const lines: string[] = ['# Available Skills', ''];

  const sortedCategories = Array.from(grouped.keys()).sort((a, b) =>
    a.toLowerCase().localeCompare(b.toLowerCase())
  );

  for (const cat of sortedCategories) {
    const entries = grouped.get(cat)!;
    if (entries.length === 0) continue;
    lines.push(`## ${cat}`);
    for (const s of entries.sort((a, b) => a.name.localeCompare(b.name))) {
      lines.push(`- ${s.name}: ${s.description}`);
    }
    lines.push('');
  }

  const total = Array.from(skills.values()).filter(m => !m.disableModelInvocation).length;
  lines.push(`Total: ${total} enabled skills`);
  lines.push('');

  // Slash commands section
  if (commands.length > 0) {
    lines.push('---', '');
    lines.push('## Slash Commands', '');
    lines.push('When the user invokes `/<skill-name>`, read the corresponding SKILL.md file for full instructions.', '');
    for (const cmd of commands.sort((a, b) => a.name.localeCompare(b.name))) {
      lines.push(`- \`/${cmd.name}\` → \`${cmd.path}\``);
    }
    lines.push('');
  }

  await vault.adapter.write('SKILLS.md', lines.join('\n'));
}

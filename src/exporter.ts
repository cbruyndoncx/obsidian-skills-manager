import { Vault } from 'obsidian';
import { scanSkills } from './scanner';

const EXPORT_TARGETS: Record<string, string> = {
  cursor: '.cursor/rules/skills.md',
  copilot: '.github/copilot-instructions.md',
  windsurf: '.windsurf/rules/skills.md',
  cline: '.clinerules/skills.md',
};

export const EXPORT_TARGET_LABELS: Record<string, string> = {
  cursor: 'Cursor',
  copilot: 'GitHub Copilot',
  windsurf: 'Windsurf',
  cline: 'Cline',
};

/**
 * Extract the body content from a SKILL.md file (everything after frontmatter).
 */
function extractBody(content: string): string {
  const match = content.match(/^---\r?\n[\s\S]*?\r?\n---\r?\n?([\s\S]*)$/);
  return match ? match[1].trim() : content.trim();
}

/**
 * Export enabled skills to config files for other AI tools.
 */
export async function exportSkills(
  vault: Vault,
  skillsDir: string,
  targets: string[]
): Promise<{ exported: string[]; errors: string[] }> {
  const exported: string[] = [];
  const errors: string[] = [];
  const adapter = vault.adapter;

  // Scan enabled skills
  const skills = await scanSkills(vault, skillsDir);
  const enabledSkills: { name: string; body: string }[] = [];

  for (const [folderName, meta] of skills) {
    if (meta.disableModelInvocation) continue;

    const skillFile = `${skillsDir}/${folderName}/SKILL.md`;
    try {
      const content = await adapter.read(skillFile);
      const body = extractBody(content);
      if (body) {
        enabledSkills.push({ name: meta.name, body });
      }
    } catch {
      errors.push(`Could not read ${skillFile}`);
    }
  }

  if (enabledSkills.length === 0) {
    errors.push('No enabled skills to export');
    return { exported, errors };
  }

  // Build combined content
  const sections = enabledSkills.map(
    (s) => `## ${s.name}\n${s.body}`
  );
  const combined = `# Skills (auto-generated by Skills Manager)\n\n${sections.join('\n\n---\n\n')}\n`;

  // Write to each target
  for (const target of targets) {
    const path = EXPORT_TARGETS[target];
    if (!path) {
      errors.push(`Unknown export target: ${target}`);
      continue;
    }

    try {
      // Ensure parent directories exist (handles nested paths like .cursor/rules/)
      const parts = path.split('/');
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join('/');
        if (dir && !(await adapter.exists(dir))) {
          await adapter.mkdir(dir);
        }
      }

      await adapter.write(path, combined);
      exported.push(EXPORT_TARGET_LABELS[target] || target);
    } catch (e) {
      errors.push(
        `Failed to write ${path}: ${e instanceof Error ? e.message : String(e)}`
      );
    }
  }

  return { exported, errors };
}
